/*.
 *	peep3bis.c - 3-instruction peephole optimizations. Part II.
 *
 *	(c) by Samuel DEVULDER
 */

#include "popt.h"

extern int p3_line;

/*.
 * ipeep3bis(ip) - look for 3-instruction optimizations at the given inst.
 */
INST *ipeep3bis(i1)
	INST	*i1;
	{
	INST	*i2;	/* the next instruction */
	INST	*i3;	/* the third instruction */

	int	op1;
	int	op2;
	int	op3;
	
	int	sm1,dm1,sr1,dr1;
	int	sm2,dm2,sr2,dr2;
	int	sm3,dm3,sr3,dr3;

	ifn(i2 = i1->next) return NULL;
	ifn(i3 = i2->next) return NULL;
	if(i2->label || i3->label) return NULL;

	op1 = i1->opcode; sm1 = i1->src.amode; sr1 = i1->src.areg; 
	dm1 = i1->dst.amode; dr1 = i1->dst.areg;

	op2 = i2->opcode; sm2 = i2->src.amode; sr2 = i2->src.areg; 
	dm2 = i2->dst.amode; dr2 = i2->dst.areg;

	op3 = i3->opcode; sm3 = i3->src.amode; sr3 = i3->src.areg; 
	dm3 = i3->dst.amode; dr3 = i3->dst.areg;

	/*
	 * Optimize code generated by *ptr++ in C..
	 */

	/*
	 *	move.l	Am,An		=>	<deleted>
	 *	addq.lw	#1,Am			<deleted>
	 *	....				....
	 *	<stuff>				<stuff>
	 *	....				....
	 *	INST.b	..(An)..	=>	INST.b	..(Am)+..
	 *
	 * An must be dead after the last instruction. Nothing in
	 * "stuff" can modify Am.
	 */
	if (OP_MOVE(op1) && (i1->flags & (LENL|LENW)) &&
	    (sm1 == REG) && ISA(sr1) && (dm1 == REG) && ISA(dr1)) 
		{
		int	rm = sr1;
		int	rn = dr1;

		if (OP_ADD(op2) &&
		    (i2->flags & (LENL|LENW)) &&
		    (sm2 == IMM) && (i2->src.disp == 1) &&
		    (dm2 == REG) && (dr2 == rm)) 
			{
			while (i3) 
				{
				if (sets(i3, rm))  goto end7;
				if (breakflow(i3)) goto end7;

				if (i3->src.amode==REGI && i3->src.areg==rn) 
					{
					if (i3->live & RM(rn)) goto end7;
					ifn (i3->flags & LENB) goto end7;

					i3->src.amode |= INC;
					i3->src.areg = rm;

				    	delinst(i1);
				    	i3 = i2->next;
				    	delinst(i2);
				    	DBG(p3_line=__LINE__+20000)
				    	goto true3;
					}
				if (i3->dst.amode==REGI && i3->dst.areg==rn) 
					{
					if (i3->live & RM(rn)) goto end7;
					ifn (i3->flags & LENB) goto end7;

					i3->dst.amode |= INC;
					i3->dst.areg = rm;

					i3 = i2->next;
				    	delinst(i1);
				    	delinst(i2);
				    	DBG(p3_line=__LINE__+20000)
				    	goto true3;
					}
				ifn (i3->next) goto end7;
				else i3 = i3->next;
				}
			}
		}
end7:	i3 = i1->next->next;
	/*
	 *	move.l	Am,An		=>	<deleted>
	 *	addq.lw	#2,Am			<deleted>
	 *	....				....
	 *	<stuff>				<stuff>
	 *	....				....
	 *	INST.w	..(An)..	=>	INST.w	..(Am)+..
	 *
	 * An must be dead after the last instruction. Nothing in
	 * "stuff" can modify Am.
	 */
	if (OP_MOVE(op1) && (i1->flags & (LENL|LENW)) &&
	    (sm1 == REG) && ISA(sr1) && (dm1 == REG) && ISA(dr1)) 
		{
		int	rm = sr1;
		int	rn = dr1;

		if (OP_ADD(op2) &&  (i2->flags & (LENL|LENW)) &&
		    (sm2 == IMM) && (i2->src.disp == 2) &&
		    (dm2 == REG) && (dr2 == rm)) 
			{
			while (i3) 
				{
				if (sets(i3, rm))  goto end9;
				if (breakflow(i3)) goto end9;

				if (i3->src.amode==REGI && i3->src.areg==rn) 
					{
					if (i3->live & RM(rn)) goto end9;
					ifn (i3->flags & LENW) goto end9;

					i3->src.amode |= INC;
					i3->src.areg = rm;

				    	delinst(i1);
				    	i3 = i2->next;
				    	delinst(i2);
				    	DBG(p3_line=__LINE__+20000)
				    	goto true3;
					}
				if (i3->dst.amode==REGI && i3->dst.areg==rn) 
					{
					if (i3->live & RM(rn)) goto end9;
					if (i3->flags & LENW)  goto end9;

					i3->dst.amode |= INC;
					i3->dst.areg = rm;

				    	delinst(i1);
				    	i3 = i2->next;
				    	delinst(i2);
				    	DBG(p3_line=__LINE__+20000)
				    	goto true3;
					}
				ifn (i3->next)	goto end9;
				else		i3 = i3->next;
				}
			}
		}
end9:
	i3 = i1->next->next;
	/*
	 *	move.l	Am,An		=>	<deleted>
	 *	addq.lw	#4,Am			<deleted>
	 *	....				....
	 *	<stuff>				<stuff>
	 *	....				....
	 *	INST.l	..(An)..	=>	INST.l	..(Am)+..
	 *
	 * An must be dead after the last instruction. Nothing in
	 * "stuff" can modify Am.
	 */
	if (OP_MOVE(op1) && (i1->flags & (LENL|LENW)) &&
	    (sm1 == REG) && ISA(sr1) && (dm1 == REG) && ISA(dr1)) 
		{
		int	rm = sr1;
		int	rn = dr1;

		if (OP_ADD(op2) &&  (i2->flags & (LENL|LENW)) &&
		    (sm2 == IMM) && (i2->src.disp == 4) &&
		    (dm2 == REG) && (dr2 == rm)) 
			{
			while (i3) 
				{
				if (sets(i3, rm))  goto end11;
				if (breakflow(i3)) goto end11;

				if (i3->src.amode==REGI && i3->src.areg==rn) 
					{
					if (i3->live & RM(rn)) goto end11;
					ifn (i3->flags & LENL) goto end11;

					i3->src.amode |= INC;
					i3->src.areg = rm;

				    	delinst(i1);
				    	i3 = i2->next;
				    	delinst(i2);
				    	DBG(p3_line=__LINE__+20000)
				    	goto true3;
					}
				if (i3->dst.amode==REGI && i3->dst.areg==rn) 
					{
					if (i3->live & RM(rn)) goto end11;
					ifn (i3->flags & LENL) goto end11;

					i3->dst.amode |= INC;
					i3->dst.areg = rm;

				    	delinst(i1);
				    	i3 = i2->next;
				    	delinst(i2);
				    	DBG(p3_line=__LINE__+20000)
				    	goto true3;
					}
				ifn (i3->next) 	goto end11;
				else		i3 = i3->next;
				}
			}
		}
end11:	i3 = i1->next->next;
	/*
	 *	move.l	Ax,Dy		=>	add.l	Ax,Ax
	 *	lsl.l	#2,Dy			add.l	Ax,Ax
	 *	move.l	Dy,Ax
	 *
	 * Where Dy is dead. UNSAFE: lsl sets the flags. add does'nt.
	 */
	if((!safe || cc_modified(i3->next)) &&
	   op1==ADD && op2==LSL && op3==MOVE &&
	   i1->flags==i2->flags && i2->flags==i3->flags && i1->flags==LENL &&
	   sm1==REG && ISA(sr1) && dm1==REG && ISD(dr1) &&
	   sm2==IMM && i2->src.disp==2 && dm2==REG && dr2==dr1 &&
	   sm3==REG && sr3==dr1 && dm3==REG && dr3==sr1 && 
	   !(i3->live & RM(dr1)))
		{
		setupinst(i1,ADD,LENL,REG,sr1,REG,dr1);
		setupinst(i2,ADD,LENL,REG,sr1,REG,dr1);
		delinst(i3);

		DBG(p3_line=__LINE__+20000)
		goto true2;
		}
	/*
	 *	move.x	X,Rm		=>	<deleted>
	 *	INST2.x	Do,Rm			INST2.x	X,Do
	 *	INST3.x	Rm,Y			INST3.x	Do,Y
	 *
	 * Where Rm!=Do and (Rm,Do) are dead and INST2=ADD | OR | AND | EOR.
	 * UNSAFE: Do may set flags in INST2 that may be untouched by INST3.
	 */
	if((!safe || cc_modified(i3) || cc_modified(i3->next)) && 
	   OP_MOVE(op1) && dm1==REG && sm2==REG && ISD(sr2) && dr1!=sr2 &&
	   (OP_ADD(op2) || OP_OR(op2) || OP_AND(op2) || OP_EOR(op2)) &&
	   dm2==REG && dr2==dr1 && i1->flags==i2->flags && i2->flags==i3->flags &&
	   sm3==REG && sr3==dr1 && !(i3->live&(RM(dr2)|RM(sr2))))
		{
		i2->src      = i1->src; i1->src.amode = NONE;
		i2->dst.areg = sr2;
		i3->src.areg = sr2;
		i2->live     =
		i2->refs     =
		i2->sets     = -1;
		delinst(i1);
		
		DBG(p3_line=__LINE__+20000)
		goto true2;
		}
	/*
	 *	move.x	#0,Rn		=>	<deleted>
	 *	cmp.x	X,Rn			tst.x	X
	 *	b<cc>	lbl			b<cci>	lbl
	 *
	 * Where Rn is dead. b<cci> is the inverse cond. branch.
	 */
	if(OP_MOVE(op1) && sm1==IMM && dm1==REG && !i1->src.disp &&
	   op2==CMP && dm2==REG && dr2==dr1 && binv(op3) &&
	   (i1->flags?i1->flags:4)==i2->flags && !(i2->live & RM(dr1)))
		{
		i2->opcode=TST;
		i2->dst.amode=NONE;
		i3->opcode=binv(op3);
		++s_brev;
		delinst(i1);
		DBG(p3_line=__LINE__)
		goto true2;
		}
	/*
	 *	move.x	#y,Rn		=>	<deleted>
	 *	cmp.x	Rm,Rn			subq.x	#abs(y),Rm  (y>0)
	 *					addq		    (y<0)
	 *	b<cc>	lbl			b<cci>	lbl
	 *
	 * Where Rm and Rn are dead and (1 <= abs(y) <= 8). b<cci> is the 
	 * inverse cond. branch.
	 */
	if(OP_MOVE(op1) && ((i1->flags?i1->flags:4)>=i2->flags) &&
	   sm1==IMM && dm1==REG && (i1->src.disp>=-8) && (i1->src.disp<=8) &&
	   op2==CMP && sm2==REG && dr2==dr1 && dm2==REG && binv(op3) &&
	   !(i2->live & (RM(sr2)|RM(dr2))))
	   	{
	   	i2->dst = i2->src;
	   	i2->src.amode = IMM;
		if(i1->src.disp>0) 
			{
			i2->opcode   = SUBQ;
			i2->src.disp = i1->src.disp;
			}
		else	{
			i2->opcode   = ADDQ;
			i2->src.disp = -i1->src.disp;
			}
		i3->opcode=binv(op3);
		++s_brev;
		delinst(i1);
		DBG(p3_line=__LINE__)
		goto true2;
	   	}
	/*
	 *	move.y #I1,Rn		=>	<deleted>
	 *	add.x  Rn,Rm			add.x #I1+I2,Rm
	 *	...				...
	 *	<stuff that does not use Rm>	<stuff>
	 *	...				...
	 *	add.x  #I2,Rm			<deleted>
	 *	
	 * Add or sub.. Where Rn is dead and y>x. UNSAFE since the 2nd 
	 * add set the flags so test if inst after last add set flags.
	 */
	if (OP_MOVE(op1) && sm1==IMM && dm1==REG &&
	    (OP_ADD(op2) || OP_SUB(op2)) && sm2==REG && dm2==REG && 
	    sr2==dr1 && ((i1->flags?i1->flags:4)>=i2->flags) && 
	    !(i2->live & RM(dr1)))
		{ INST *ni = i2->next;
		while(ni && !breakflow(ni) && !uses(ni,dr2)) ni = ni->next;
		if(ni && uses(ni,dr2) && !ni->label &&
		   (OP_ADD(ni->opcode)||OP_SUB(ni->opcode)) && 
		   ni->src.amode == IMM && ni->dst.amode == REG && 
		   ni->dst.areg == dr2 && (!safe || cc_modified(ni->next)))
			{
			if(OP_ADD(op2))	
				i1->src.disp += OP_ADD(ni->opcode)?
						ni->src.disp:-ni->src.disp;
			else 	i1->src.disp -= OP_ADD(ni->opcode)?
						ni->src.disp:-ni->src.disp;
			if(i1->src.disp>8 || i1->src.disp<-8)
				{
				if(op2==ADDQ)		i2->opcode=ADDI;
				else if(op2==SUBQ)	i2->opcode=SUBI;
				}
			i2->src.amode = IMM;
			i2->src.disp  = i1->src.disp;
			delinst(i1);
			delinst(ni);
			DBG(p3_line=__LINE__)
			goto true2;
			}
		}
	return NULL;
true:	return i1->next;
true2:	return i2;
true3:	return i3;
}
